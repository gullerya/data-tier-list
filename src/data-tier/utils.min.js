const t=/\s*[,;]\s*/,e=/\s*=>\s*/,r={A:"href",ANIMATE:"href",AREA:"href",BASE:"href",DISCARD:"href",IMAGE:"href",LINK:"href",PATTERN:"href",use:"href",INPUT:"value",SELECT:"value",TEXTAREA:"value",IFRAME:"src",IMG:"src",SOURCE:"src"},n=["INPUT","SELECT","TEXTAREA"],i="abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",o=i.length;export{l as extractViewParams,f as getPath,h as setPath,p as callViewFunction,d as getRandomKey};export{r as DEFAULT_TARGET,n as DEFAULT_EVENTS_CHANGE};class s{constructor(t,e,r,n,i,o,s){this.tieKey=t,this.rawPath=e,this.path=r,this.targetProperty=n,this.changeEvent=i,this.isFunctional=o,this.fParams=s,this.iClasses=null}}function l(e){const r=e.getAttribute("data-tie");if(r){const n=function(e,r){const n=[],i={},o=e.trim().split(t),s=o.length;let l,u,f,h=0;for(;h<s;h++)if((l=o[h])&&(u&&(u+=","+l),!(l.indexOf("(")>0&&(u=l).indexOf(")")<0)))try{u?(f=a(u),u=null):f=c(l,r),f.targetProperty in i?console.error(`elements's property '${f.targetProperty}' tied more than once; all but first tie dismissed`):(n.push(f),i[f.targetProperty]=!0)}catch(t){console.error(`failed to parse one of a multi param parts (${l}), skipping it`,t)}return n}(r,e);return n.length?n:null}return null}function a(t){const[e,r]=t.split(/[()]/),n=r.trim().split(/\s*,\s*/).map(u);if(!n.length)throw new Error(`functional tie parameter MUST have at least one tied argument, '${t}' doesn't`);return new s(null,null,null,e,null,!0,n)}function c(t,i){let[o,l,a]=t.split(e);const{tieKey:c,rawPath:f,path:h}=u(o);l=l||function(t){let e=r[t.nodeName];e?"checkbox"===t.type&&(e="checked"):e="textContent";return e}(i),a=a||function(t){let e=null;n.includes(t.nodeName)&&(e="change");return e}(i);const p=new s(c,f,h,l,a,!1,null);return"classList"===l&&(p.iClasses=Array.from(i.classList)),p}function u(t){const[e,r=""]=t.split(":");if(!e)throw new Error(`tie key missing in tie parameter '${t}'; expected example: "orders:0.address.apt => title"`);return{tieKey:e,rawPath:r,path:r.split(".").filter(Boolean)}}function f(t,e){if(!t)return t;const r=e,n=r.length;if(!n)return t;let i,o=t,s=0;for(;s<n;s++)if(null===(o=o[i=r[s]])||void 0===o)return o;return o}function h(t,e,r){if(!t)return;const n=e.length;let i,o,s=0;for(;s<n-1;s++)if((o=t[i=e[s]])&&"object"==typeof o)t=o;else if(void 0===o||null===o)t[i]={},t=t[i];else if("object"!=typeof o)return void console.error("setting deep path MAY NOT override primitives along the way");t[e[s]]=r}function p(t,e,r){try{t[e].apply(t,r)}catch(n){console.error(`failed to call '${e}' of '${t}' with '${r}'`,n)}}function d(t){let e="",r=t;const n=crypto.getRandomValues(new Uint8Array(t));for(;r--;)e+=i.charAt(o*n[r]/256);return e}