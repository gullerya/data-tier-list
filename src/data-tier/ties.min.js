import{ensureObservable,getPath,callViewFunction,getRandomKey}from"./utils.min.js";const MODEL_KEY=Symbol("model.key"),tieNameValidator=/^[a-zA-Z0-9]+$/,reservedTieNames=["scope"];class Tie{constructor(e,t,i){this.key=e,this.ties=i,this.model=t}set model(e){this[MODEL_KEY]=ensureObservable(e),this[MODEL_KEY].observe(e=>this.processDataChanges(e))}get model(){return this[MODEL_KEY]}processDataChanges(e){const t=this.ties.dti.views.obtainTieViews(this.key),i=t._pathsCache,s=i.length;let o,r,a,n,h,l,d,c,y,p,f,m,w,E,g,u,v,T="";if(s)for(o=0,r=e.length;o<r;o++)if(l=(h=(a=e[o]).path).length,!h.some(e=>"symbol"==typeof e)){for(E=!1,n=a.object,!Array.isArray(n)||"insert"!==a.type&&"delete"!==a.type||isNaN(h[h.length-1])?1===l?T=h[0]:l&&(T=2===l?h[0]+"."+h[1]:h.join(".")):(T=h.slice(0,-1).join("."),E=!0),f=T.length,d=s,v=new Map;d;)if(f>(c=i[--d]).length?(m=c,w=T):(m=T,w=c),g=m===w&&!E,0===w.indexOf(m))for(p=(y=t[c]).length;p;){u=y[--p];let e=v.get(u);e||(e={},v.set(u,e)),e[c]=g}this.updateViews(v,a)}}updateViews(e,t){let i,s;e.forEach((e,o)=>{for(i=o[this.ties.dti.paramsKey],s=i.length;s;){const r=i[--s];if(r.isFunctional){if(r.fParams.some(t=>t.tieKey===this.key&&t.rawPath in e)){let e=!1;const i=[];r.fParams.forEach(t=>{let s;const o=this.ties.get(t.tieKey);o&&(s=getPath(o,t.path),e=!0),i.push(s)}),e&&(i.push([t]),callViewFunction(o,r.targetProperty,i))}}else{if(r.tieKey!==this.key)continue;if(!(r.rawPath in e))continue;let i;void 0===(i=t&&void 0!==t.value&&e[r.rawPath]?t.value:getPath(this[MODEL_KEY],r.path))&&(i=""),this.ties.dti.views.setViewProperty(o,r,i)}}})}}export class Ties{constructor(e){this.dti=e,this.ties={}}get(e){const t="string"==typeof e?e:e?e[this.dti.scopeRootKey]:void 0,i=this.ties[t];return i?i.model:null}create(e,t){if(this.ties[e])throw new Error(`tie '${e}' already exists`);if(null===t)throw new Error("initial model, when provided, MUST NOT be null");this.validateTieKey(e);let i=e;"string"!=typeof i&&((i=e[this.dti.scopeRootKey])||(i=getRandomKey(16),e[this.dti.scopeRootKey]=i));const s=this.dti.views.obtainTieViews(i),o=new Tie(i,t,this,s);return this.ties[i]=o,o.processDataChanges([{path:[]}]),o.model}update(e,t){if(!t||"object"!=typeof t)throw new Error("model MUST be a non-null object");const i="string"==typeof e?e:e?e[this.dti.scopeRootKey]:void 0,s=this.ties[i];return s?(s.model!==t&&(s.model=t,s.processDataChanges([{path:[]}])),s.model):this.create(i,t)}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e[this.dti.scopeRootKey]:Object.keys(this.ties).find(t=>this.ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);this.ties[t]&&(delete this.ties[t],this.dti.views.deleteTieViews(t))}validateTieKey(e){if(!e)throw new Error(`invalid key '${e}'`);if("string"==typeof e){if(!tieNameValidator.test(e))throw new Error(`tie key MUST match ${tieNameValidator}; '${e}' doesn't`);if(reservedTieNames.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${reservedTieNames.join(", ")}`)}else if(!e.nodeType||e.nodeType!==Node.ELEMENT_NODE)throw new Error(`invalid key '${e}'`)}};