import{ensureObservable as e,getPath as t,callViewFunction as i,getRandomKey as s}from"./utils.min.js";const o=Symbol("model.key"),r=/^[a-zA-Z0-9]+$/,n=["scope"];class a{constructor(e,t,i){this.key=e,this.ties=i,this.model=t}set model(t){this[o]=e(t),this[o].observe(e=>this.processDataChanges(e))}get model(){return this[o]}processDataChanges(e){const t=this.ties.dti.views.obtainTieViews(this.key),i=t._pathsCache,s=i.length;let o,r,n,a,h,l,d,p,c,f,y,u,g,w,m,b,T,v="";if(s)for(o=0,r=e.length;o<r;o++)if(l=(h=(n=e[o]).path).length,!h.some(e=>"symbol"==typeof e)){for(w=!1,a=n.object,!Array.isArray(a)||"insert"!==n.type&&"delete"!==n.type||isNaN(h[h.length-1])?1===l?v=h[0]:l&&(v=2===l?h[0]+"."+h[1]:h.join(".")):(v=h.slice(0,-1).join("."),w=!0),y=v.length,d=s,T=[];d--;)if(y>(p=i[d]).length?(u=p,g=v):(u=v,g=p),m=u===g&&!w,0===g.indexOf(u))for(f=(c=t[p]).length;f--;)b=c[f],T.push([b,p,m]);this.updateViews(T,n)}}updateViews(e,s){let r,n;for(const[a,h,l]of e)for(n=(r=a[this.ties.dti.paramsKey]).length;n--;){const e=r[n];if(e.isFunctional){if(e.fParams.some(e=>e.tieKey===this.key&&e.rawPath===h)){let o=!1;const r=[];e.fParams.forEach(e=>{let i;const s=this.ties.get(e.tieKey);s&&(i=t(s,e.path),o=!0),r.push(i)}),o&&(r.push([s]),i(a,e.targetProperty,r))}}else{if(e.tieKey!==this.key||e.rawPath!==h)continue;let i;void 0===(i=s&&void 0!==s.value&&l?s.value:t(this[o],e.path))&&(i=""),this.ties.dti.views.setViewProperty(a,e,i)}}}}export class Ties{constructor(e){this.dti=e,this.ties={}}get(e){const t="string"==typeof e?e:e&&e.getAttribute?e.getAttribute("data-tie-scope"):null,i=this.ties[t];return i?i.model:null}create(e,t){if(null===t)throw new Error("initial model, when provided, MUST NOT be null");let i;if("string"==typeof e?i=e:e&&e.nodeType===Node.ELEMENT_NODE&&((i=e.getAttribute("data-tie-scope"))?console.log("inspect this"):(i=s(16),e.setAttribute("data-tie-scope",i))),Ties.validateTieKey(i),this.ties[i])throw new Error(`tie '${i}' already exists`);e.nodeType&&this.dti.views.addScope(e);const o=new a(i,t,this);return this.ties[i]=o,o.processDataChanges([{path:[]}]),o.model}update(e,t){if(!t||"object"!=typeof t)throw new Error("model MUST be a non-null object");const i="string"==typeof e?e:e&&e.getAttribute?e.getAttribute("data-tie-scope"):null,s=this.ties[i];return s?(s.model!==t&&(s.model=t,s.processDataChanges([{path:[]}])),s.model):this.create(e,t)}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e.getAttribute("data-tie-scope"):Object.keys(this.ties).find(t=>this.ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);this.ties[t]&&(delete this.ties[t],this.dti.views.deleteTieViews(t))}static validateTieKey(e){if(!e||"string"!=typeof e)throw new Error(`invalid key '${e}'`);if(!r.test(e))throw new Error(`tie key MUST match ${r}; '${e}' doesn't`);if(n.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${n.join(", ")}`)}};