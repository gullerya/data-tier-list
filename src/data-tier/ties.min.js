import{Observable as e}from"./object-observer.min.js";import{getPath as t,callViewFunction as i,getRandomKey as s}from"./utils.min.js";export{e as Observable};const o=Symbol("model.key"),r=/^[a-zA-Z0-9]+$/,a=["scope"];class n{constructor(e,t,i){this.key=e,this.ties=i,this.model=t}set model(t){const[i,s]=function(t={}){return e.isObservable(t)?[t,!0]:t&&"object"==typeof t?[e.from(t),!0]:[t,!1]}(t);this[o]=i,s&&this[o].observe(e=>this.processDataChanges(e))}get model(){return this[o]}processDataChanges(e){const t=this.ties._dti.views.obtainTieViews(this.key),i=t._pathsCache,s=i.length;let o,r,a,n,h,l,d,c,p,f,y,g,m,u,w,b,v="";if(s)for(o=0,r=e.length;o<r;o++)if(l=(h=(a=e[o]).path).length,!h.some(e=>"symbol"==typeof e))for(u=!1,n=a.object,!Array.isArray(n)||"insert"!==a.type&&"delete"!==a.type||isNaN(h[h.length-1])?1===l?v=h[0]:l&&(v=2===l?h[0]+"."+h[1]:h.join(".")):(v=h.slice(0,-1).join("."),u=!0),y=v.length,d=s;d--;)if(y>(c=i[d]).length?(g=c,m=v):(g=v,m=c),w=g===m&&!u,0===m.indexOf(g))for(f=(p=t[c]).length;f--;)b=p[f],this.updateView(b,c,w,a)}updateView(e,s,r,a){const n=e[this.ties._dti.paramsKey];let h=n.length;for(;h--;){const l=n[h];if(l.isFunctional){if(l.fParams.some(e=>e.tieKey===this.key&&e.rawPath===s)){let s=!1;const o=[];l.fParams.forEach(e=>{let i;const r=this.ties.get(e.tieKey);r&&(i=t(r,e.path),s=!0),o.push(i)}),s&&(o.push([a]),i(e,l.targetProperty,o))}}else{if(l.tieKey!==this.key||l.rawPath!==s)continue;let i;i=void 0!==a.value&&r?a.value:t(this[o],l.path),this.ties._dti.views.setViewProperty(e,l,i)}}}}export class Ties{constructor(e){this._dti=e,this._ties={}}get(e){const t="string"==typeof e?e:e&&e.getAttribute?e.getAttribute("data-tie-scope"):null,i=this._ties[t];return i?i.model:void 0}create(e,t){let i;if("string"==typeof e?i=e:e&&e.nodeType===Node.ELEMENT_NODE&&((i=e.getAttribute("data-tie-scope"))?console.log("inspect this"):(i=s(16),e.setAttribute("data-tie-scope",i))),Ties.validateTieKey(i),this._ties[i])throw new Error(`tie '${i}' already exists`);e.nodeType&&this._dti.views.addScope(e);const o=new n(i,t,this);return this._ties[i]=o,o.processDataChanges([{path:[]}]),o.model}update(e,t){if(void 0===t)throw new Error(`illegal model '${t}'`);const i="string"==typeof e?e:e&&e.getAttribute?e.getAttribute("data-tie-scope"):null,s=this._ties[i];return s?(s.model!==t&&(s.model=t,s.processDataChanges([{path:[]}])),s.model):this.create(e,t)}remove(e){let t=e;if("object"==typeof e)t=e.nodeType===Node.ELEMENT_NODE?e.getAttribute("data-tie-scope"):Object.keys(this._ties).find(t=>this._ties[t].model===e);else if("string"!=typeof e)throw new Error(`invalid tieToRemove parameter ${e}`);this._ties[t]&&(delete this._ties[t],this._dti.views.deleteTieViews(t))}static validateTieKey(e){if(!e||"string"!=typeof e)throw new Error(`invalid key '${e}'`);if(!r.test(e))throw new Error(`tie key MUST match ${r}; '${e}' doesn't`);if(a.indexOf(e)>=0)throw new Error(`tie key MUST NOT be one of those: ${a.join(", ")}`)}};