const t="insert",e="update",o="delete",r=Symbol("observable-meta-key"),n={async:1},s={path:1,pathsOf:1,pathsFrom:1},i={[r]:{value:null},observe:{value:function(t,e){if("function"!=typeof t)throw new Error(`observer MUST be a function, got '${t}'`);const o=this[r].observers;if(o.some(e=>e[0]===t))console.warn("observer may be bound to an observable only once; will NOT rebind");else{let r;r=e?function(t){const e={};if(void 0!==t.path){if("string"!=typeof t.path||""===t.path)throw new Error('"path" option, if/when provided, MUST be a non-empty string');e.path=t.path}if(void 0!==t.pathsOf){if(t.path)throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');if("string"!=typeof t.pathsOf)throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');e.pathsOf=t.pathsOf.split(".").filter(t=>t)}if(void 0!==t.pathsFrom){if(t.path||t.pathsOf)throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf"  option/s');if("string"!=typeof t.pathsFrom||""===t.pathsFrom)throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');e.pathsFrom=t.pathsFrom}const o=Object.keys(t).filter(t=>!s.hasOwnProperty(t));if(o.length)throw new Error(`'${o.join(", ")}' is/are not a valid observer option/s`);return e}(e):{},o.push([t,r])}}},unobserve:{value:function(){const t=this[r].observers;let e=t.length;if(e){let o=arguments.length;if(o)for(;o--;){let r=e;for(;r--;)t[r][0]===arguments[o]&&(t.splice(r,1),e--)}else t.splice(0)}}}},a=function(t,e){i[r].value=e;const o=Object.keys(t),n=Object.defineProperties({},i);let s,a=o.length;for(;a--;)n[s=o[a]]=u(t[s],s,e);return n},h=function(t,e){let o=t.length;i[r].value=e;const n=Object.defineProperties(new Array(o),i);for(;o--;)n[o]=u(t[o],o,e);return n},l=function(t,e){return i[r].value=e,Object.defineProperties(t,i),t},p=function(t,e){let o=e;if(t.path){const r=t.path;o=e.filter(t=>t.path.join(".")===r)}else if(t.pathsOf){const r=t.pathsOf;o=e.filter(t=>t.path.length===r.length+1||t.path.length===r.length&&("reverse"===t.type||"shuffle"===t.type))}else if(t.pathsFrom){const r=t.pathsFrom;o=e.filter(t=>t.path.join(".").startsWith(r))}return o},c=function(){const t=this.batches;this.batches=null;for(const e of t)e[0](e[1])},f=function(t,e){let o,r,n,s,i,a,h,l,f=t;const u=e.length;do{for(a=(o=f.observers).length;a--;)try{if(r=o[a],n=r[0],s=r[1],(i=p(s,e)).length)if(f.options.async){f.batches||(f.batches=[],queueMicrotask(c.bind(f)));let t=f.batches.find(t=>t[0]===n);t||(t=[n,[]],f.batches.push(t)),Array.prototype.push.apply(t[1],i)}else n(i)}catch(t){console.error(`failed to deliver changes to listener ${n}`,t)}let t;if(f.parent){t=new Array(u);for(let o=0;o<u;o++)l=e[o],h=[f.ownKey,...l.path],t[o]={type:l.type,path:h,value:l.value,oldValue:l.oldValue,object:l.object};e=t,f=f.parent}else f=null}while(f)},u=function(t,e,o){return t&&"object"==typeof t?Array.isArray(t)?new m({target:t,ownKey:e,parent:o}).proxy:ArrayBuffer.isView(t)?new x({target:t,ownKey:e,parent:o}).proxy:t instanceof Date||t instanceof Blob||t instanceof Error?t:new O({target:t,ownKey:e,parent:o}).proxy:t},y=function(){const t=this[r],e=t.target;let o,n,s;for(e.reverse(),o=0,n=e.length;o<n;o++)if((s=e[o])&&"object"==typeof s){const t=s[r];t&&(t.ownKey=o)}return f(t,[{type:"reverse",path:[],object:this}]),this},b=function(t){const e=this[r],o=e.target;let n,s,i;for(o.sort(t),n=0,s=o.length;n<s;n++)if((i=o[n])&&"object"==typeof i){const t=i[r];t&&(t.ownKey=n)}return f(e,[{type:"shuffle",path:[],object:this}]),this},w=function(o,n,s){const i=this[r],a=i.target,h=[],l=a.length,p=a.slice(0);if(n=void 0===n?0:n<0?Math.max(l+n,0):Math.min(n,l),s=void 0===s?l:s<0?Math.max(l+s,0):Math.min(s,l),n<l&&s>n){let l;a.fill(o,n,s);for(let o,c,f=n;f<s;f++)o=a[f],a[f]=u(o,f,i),p.hasOwnProperty(f)?((c=p[f])&&"object"==typeof c&&(l=c[r])&&(c=l.detach()),h.push({type:e,path:[f],value:a[f],oldValue:c,object:this})):h.push({type:t,path:[f],value:a[f],object:this});f(i,h)}return this},g=function(t,o,n){const s=this[r],i=s.target,a=i.length;t=t<0?Math.max(a+t,0):t,o=void 0===o?0:o<0?Math.max(a+o,0):Math.min(o,a),n=void 0===n?a:n<0?Math.max(a+n,0):Math.min(n,a);const h=Math.min(n-o,a-t);if(t<a&&t!==o&&h>0){const a=i.slice(0),l=[];i.copyWithin(t,o,n);for(let o,n,p,c=t;c<t+h;c++)(o=i[c])&&"object"==typeof o&&(o=u(o,c,s),i[c]=o),(n=a[c])&&"object"==typeof n&&(p=n[r])&&(n=p.detach()),"object"!=typeof o&&o===n||l.push({type:e,path:[c],value:o,oldValue:n,object:this});f(s,l)}return this},v={pop:function(){const t=this[r],e=t.target,n=e.length-1;let s=e.pop();if(s&&"object"==typeof s){const t=s[r];t&&(s=t.detach())}return f(t,[{type:o,path:[n],oldValue:s,object:this}]),s},push:function(){const e=this[r],o=e.target,n=arguments.length,s=new Array(n),i=o.length;for(let t=0;t<n;t++)s[t]=u(arguments[t],i+t,e);const a=Reflect.apply(o.push,o,s),h=[];for(let e=i,r=o.length;e<r;e++)h[e-i]={type:t,path:[e],value:o[e],object:this};return f(e,h),a},shift:function(){const t=this[r],e=t.target;let n,s,i,a,h;for((n=e.shift())&&"object"==typeof n&&(h=n[r])&&(n=h.detach()),s=0,i=e.length;s<i;s++)(a=e[s])&&"object"==typeof a&&(h=a[r])&&(h.ownKey=s);return f(t,[{type:o,path:[0],oldValue:n,object:this}]),n},unshift:function(){const e=this[r],o=e.target,n=arguments.length,s=new Array(n);for(let t=0;t<n;t++)s[t]=u(arguments[t],t,e);const i=Reflect.apply(o.unshift,o,s);for(let t,e=0,n=o.length;e<n;e++)if((t=o[e])&&"object"==typeof t){const o=t[r];o&&(o.ownKey=e)}const a=s.length,h=new Array(a);for(let e=0;e<a;e++)h[e]={type:t,path:[e],value:o[e],object:this};return f(e,h),i},reverse:y,sort:b,fill:w,copyWithin:g,splice:function(){const n=this[r],s=n.target,i=arguments.length,a=new Array(i),h=s.length;for(let t=0;t<i;t++)a[t]=u(arguments[t],t,n);const l=0===i?0:a[0]<0?h+a[0]:a[0],p=i<2?h-l:a[1],c=Math.max(i-2,0),y=Reflect.apply(s.splice,s,a),b=s.length;let w,g,v,d;for(let t,e=0;e<b;e++)(t=s[e])&&"object"==typeof t&&(w=t[r])&&(w.ownKey=e);for(g=0,v=y.length;g<v;g++)(d=y[g])&&"object"==typeof d&&(w=d[r])&&(y[g]=w.detach());const j=[];let O;for(O=0;O<p;O++)O<c?j.push({type:e,path:[l+O],value:s[l+O],oldValue:y[O],object:this}):j.push({type:o,path:[l+O],oldValue:y[O],object:this});for(;O<c;O++)j.push({type:t,path:[l+O],value:s[l+O],object:this});return f(n,j),y}},d={reverse:y,sort:b,fill:w,copyWithin:g,set:function(t,o){const n=this[r],s=n.target,i=t.length,a=s.slice(0);o=o||0,s.set(t,o);const h=new Array(i);for(let t=o;t<i+o;t++)h[t-o]={type:e,path:[t],value:s[t],oldValue:a[t],object:this};f(n,h)}};class j{constructor(t,e){const o=t.target,r=t.parent,n=t.ownKey;r&&void 0!==n?(this.parent=r,this.ownKey=n):(this.parent=null,this.ownKey=null);const s=e(o,this);this.observers=[],this.revokable=Proxy.revocable(s,this),this.proxy=this.revokable.proxy,this.target=s,this.processOptions(t.options)}processOptions(t){if(t){if("object"!=typeof t)throw new Error(`Observable options if/when provided, MAY only be a non-null object, got '${t}'`);const e=Object.keys(t).filter(t=>!n.hasOwnProperty(t));if(e.length)throw new Error(`'${e.join(", ")}' is/are not a valid Observable option/s`);this.options=Object.assign({},t)}else this.options={}}detach(){return this.parent=null,this.target}set(o,n,s){let i=o[n];if(s!==i){const a=u(s,n,this);if(o[n]=a,i&&"object"==typeof i){const t=i[r];t&&(i=t.detach())}const h=void 0===i?[{type:t,path:[n],value:a,object:this.proxy}]:[{type:e,path:[n],value:a,oldValue:i,object:this.proxy}];f(this,h)}return!0}deleteProperty(t,e){let n=t[e];if(delete t[e],n&&"object"==typeof n){const t=n[r];t&&(n=t.detach())}const s=[{type:o,path:[e],oldValue:n,object:this.proxy}];return f(this,s),!0}}class O extends j{constructor(t){super(t,a)}}class m extends j{constructor(t){super(t,h)}get(t,e){return v.hasOwnProperty(e)?v[e]:t[e]}}class x extends j{constructor(t){super(t,l)}get(t,e){return d.hasOwnProperty(e)?d[e]:t[e]}}class M{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(t,e){if(t&&"object"==typeof t){if(t[r])return t;if(Array.isArray(t))return new m({target:t,ownKey:null,parent:null,options:e}).proxy;if(ArrayBuffer.isView(t))return new x({target:t,ownKey:null,parent:null,options:e}).proxy;if(t instanceof Date||t instanceof Blob||t instanceof Error)throw new Error(`${t} found to be one of a on-observable types`);return new O({target:t,ownKey:null,parent:null,options:e}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(t){return!(!t||!t[r])}}Object.freeze(M);export{M as Observable};